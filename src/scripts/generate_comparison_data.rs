use std::fs::File;
use std::io::{self, Result, Write,BufReader,BufRead};
use std::collections::HashMap;

use csv::ReaderBuilder;

use similarity_methods::utils::tensor;
#[allow(unused_imports)]
use similarity_methods::utils::sequence;

struct Metadata {
    sequence_length: usize,
    min_edit_distance: usize,
    max_edit_distance: usize,
}

struct KHashmap {
    data: HashMap<usize, Vec<f64>>,
}

impl KHashmap {
    // Create a new MyStruct with an empty HashMap
    fn new(k_range: &Vec<usize>, edit_distance_range: usize) -> KHashmap {
        KHashmap {
            data: {
                let data = HashMap::new();
                for k in k_range {
                    data.insert(k.clone(), vec![0.0; edit_distance_range]);
                }
                data
            },
        }
    }

    // Insert a value into the HashMap
    fn insert(&mut self, key: usize, value: Vec<f64>) {
        self.data.insert(key, value);
    }

    // Get a reference to a value in the HashMap
    fn get(&self, key: &usize) -> Option<&Vec<f64>> {
        self.data.get(key)
    }

    // Get a mutable reference to a value in the HashMap
    fn get_mut(&mut self, key: &usize) -> Option<&mut Vec<f64>> {
        self.data.get_mut(key)
    }

}
/*
 * This function parses metadata from the database file generated by generate_string_pairs.rs.
 * I'm having trouble with the parse() method, which says that:
 * the trait `From<ParseIntError>` is not implemented for `std::io::Error`. 
 */
fn read_metadata(sequence_database_file_name: &String) -> Result<Metadata> {
    let file = File::open(sequence_database_file_name)?;
    let mut reader = BufReader::new(file);

    let mut first_line = String::new();
    reader.read_line(&mut first_line)?;
    let sequence_length: usize = first_line.trim().strip_prefix("# base string length=")
        .unwrap().parse()?;

    let mut second_line = String::new();
    reader.read_line(&mut second_line)?;
    let min_edit_distance: usize = second_line.trim().strip_prefix("# minimum edit distance=")
        .unwrap().parse()?;

    let mut third_line = String::new();
    reader.read_line(&mut third_line)?;
    let max_edit_distance: usize = third_line.trim().strip_prefix("# maximum edit distance=")
        .unwrap().parse()?;

    let metadata = Metadata {
        sequence_length: sequence_length,
        min_edit_distance: min_edit_distance,
        max_edit_distance: max_edit_distance
    };
    Ok(metadata)
}

/* Please see this repo's README file, it contains the pseudocode for this script.
 */
fn main() -> Result<()> {
    let k_range: Vec<usize> = [2,3,4].to_vec();
    let sequence_database_file_name = "../../tests/inputs/sequences_1000.csv".to_string();

    let metadata = read_metadata(&sequence_database_file_name)?;
    let _sequence_length = metadata.sequence_length;
    let max_edit_distance = metadata.max_edit_distance;
    let min_edit_distance = metadata.min_edit_distance;

    // Initialize the data structures this function will return. 
    // edit_distance_sums and edit_distance_squared_sums are HashMaps that contain
    // the sums and squaned sums of estimated distances between strings for a given k and edit distance.
    let mut edit_distance_sums = KHashmap::new(&k_range, max_edit_distance);
    let mut edit_distance_squared_sums = KHashmap::new(&k_range, max_edit_distance);

    // edit_distance_counts contains the number of string pairs with a true edit distance given by the index.
    let mut edit_distance_counts: Vec<usize> = vec![0; max_edit_distance];

    let file = File::open(sequence_database_file_name)?;
    let mut rdr = ReaderBuilder::new().from_reader(file);

    for result in rdr.records() {
        let record = result?;
        let string1_chars: Vec<char> = record[0].chars().collect(); // (string of ~1000 letters)
        let string2_chars: Vec<char> = record[1].chars().collect(); // (string of ~1000 letters)
        let edit_distance: usize = record[2].parse().map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))?;
        edit_distance_counts[edit_distance] += 1;
        
        // COMPUTATIONS
        for k in k_range {
            let estimated_distance = tensor::l2norm(&string1_chars, &string2_chars, k);
            edit_distance_sums.get_mut(&k).unwrap()[edit_distance] += estimated_distance;
            edit_distance_squared_sums.get_mut(&k).unwrap()[edit_distance] += estimated_distance * estimated_distance;
        }
    }

    let mut confidence_intervals: HashMap<usize, Vec<(f64, f64)>> = HashMap::new();
    let mut means: HashMap<usize, Vec<f64>> = HashMap::new();
    for k in k_range {
        confidence_intervals.insert(k, vec![(0.0, 0.0); max_edit_distance]);

        means.insert(k, vec![0.0; max_edit_distance]);
        for edit_distance in min_edit_distance..max_edit_distance {
            confidence_intervals.get_mut(&k).unwrap()[edit_distance] = {
                let sum = edit_distance_sums.get(&k).unwrap()[edit_distance];
                let squared_sum = edit_distance_squared_sums.get(&k).unwrap()[edit_distance];
                let count = edit_distance_counts[edit_distance] as f64;

                let mean = sum / count;
                let variance = (squared_sum - mean * sum) / count;
                let mean_se = (variance / count as f64).sqrt();
                means.get_mut(&k).unwrap()[edit_distance] = mean;
                (mean - mean_se, mean + mean_se)
            }
        }
    }

    let mut file = File::create("data.csv")?;

    let mut column_names: Vec<String> = Vec::new();
    column_names.push("edit distance".to_string());
    for k in k_range {
        column_names.push(format!("mean (k={})", k));
        column_names.push(format!("lower confidence bound (k={})", k));
        column_names.push(format!("upper confidence bound (k={})", k));
    }

    let header_row = column_names.join(",");
    writeln!(&mut file, "{}", header_row)?;

    for edit_distance in min_edit_distance..max_edit_distance {
        let mut row_values: Vec<String> = Vec::new();
        row_values.push(edit_distance.to_string());
        for k in k_range {
            row_values.push(means[&k][edit_distance].to_string()); // mean
            row_values.push(format!("{}", confidence_intervals[&k][edit_distance].0.to_string()));
            row_values.push(format!("{}", confidence_intervals[&k][edit_distance].1.to_string()));
        }
        let row = row_values.join(",");
        writeln!(&mut file, "{}", row)?;
    }
    Ok(())
}